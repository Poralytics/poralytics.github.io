/**
 * CODE FIXES ROUTES
 * GÃ©nÃ©ration automatique de code de correction
 */
const express = require('express');
const router = express.Router();
const db = require('../config/database');
const { auth } = require('../middleware/auth');
const { asyncHandler } = require('../utils/error-handler');
const remediationGenerator = require('../services/remediation-generator');

// Get automated fix for a vulnerability
router.get('/:vulnId', auth, asyncHandler(async (req, res) => {
  const vuln = db.prepare(`
    SELECT v.*, s.user_id FROM vulnerabilities v
    JOIN scans s ON v.scan_id = s.id
    WHERE v.id = ? AND s.user_id = ?
  `).get(req.params.vulnId, req.user.userId);

  if (!vuln) {
    return res.status(404).json({ error: 'Vulnerability not found' });
  }

  const fix = remediationGenerator.generateFix(vuln);

  res.json({
    vulnerability: {
      id: vuln.id,
      title: vuln.title,
      category: vuln.category,
      severity: vuln.severity
    },
    fix,
    generatedAt: new Date()
  });
}));

// Get all fixes for a scan
router.get('/scan/:scanId', auth, asyncHandler(async (req, res) => {
  const scan = db.prepare('SELECT * FROM scans WHERE id = ? AND user_id = ?')
    .get(req.params.scanId, req.user.userId);

  if (!scan) {
    return res.status(404).json({ error: 'Scan not found' });
  }

  const vulns = db.prepare(`
    SELECT * FROM vulnerabilities WHERE scan_id = ?
    ORDER BY CASE severity 
      WHEN 'critical' THEN 1 
      WHEN 'high' THEN 2 
      WHEN 'medium' THEN 3 
      WHEN 'low' THEN 4 
      ELSE 5 END
  `).all(scan.id);

  const fixes = vulns.map(vuln => ({
    vulnerabilityId: vuln.id,
    title: vuln.title,
    category: vuln.category,
    severity: vuln.severity,
    fix: remediationGenerator.generateFix(vuln)
  }));

  res.json({
    scan_id: scan.id,
    total_fixes: fixes.length,
    fixes
  });
}));

// Generate Pull Request (GitHub integration)
router.post('/generate-pr/:vulnId', auth, asyncHandler(async (req, res) => {
  const vuln = db.prepare(`
    SELECT v.*, s.user_id, d.url FROM vulnerabilities v
    JOIN scans s ON v.scan_id = s.id
    JOIN domains d ON s.domain_id = d.id
    WHERE v.id = ? AND s.user_id = ?
  `).get(req.params.vulnId, req.user.userId);

  if (!vuln) {
    return res.status(404).json({ error: 'Vulnerability not found' });
  }

  const fix = remediationGenerator.generateFix(vuln);

  // Generate PR description
  const prTitle = `fix: ${vuln.title}`;
  const prBody = `
## Security Fix: ${vuln.category}

**Severity**: ${vuln.severity.toUpperCase()}  
**CVSS Score**: ${vuln.cvss_score}

### Vulnerability Description
${vuln.description || 'See scan report for details'}

### Proposed Fix
${fix.explanation || 'See code changes below'}

${fix.before ? `
### Before (Vulnerable)
\`\`\`${fix.language || 'javascript'}
${fix.before}
\`\`\`
` : ''}

${fix.after ? `
### After (Secure)
\`\`\`${fix.language || 'javascript'}
${fix.after}
\`\`\`
` : ''}

${fix.npmPackages && fix.npmPackages.length > 0 ? `
### Dependencies to Install
\`\`\`bash
npm install ${fix.npmPackages.join(' ')}
\`\`\`
` : ''}

${fix.testCode ? `
### Test
\`\`\`${fix.language || 'javascript'}
${fix.testCode}
\`\`\`
` : ''}

---
ðŸ¤– Generated by NEXUS Security Scanner  
ðŸ“‹ Vulnerability ID: ${vuln.id}  
ðŸ”— Scan Report: /api/reports/${vuln.scan_id}/pdf
  `.trim();

  res.json({
    pullRequest: {
      title: prTitle,
      body: prBody,
      branch: `security/fix-${vuln.category.toLowerCase().replace(/\s+/g, '-')}-${vuln.id}`,
      labels: ['security', `severity-${vuln.severity}`]
    },
    instructions: `
1. Create a new branch: git checkout -b security/fix-${vuln.id}
2. Apply the fix from the code above
3. Run tests to verify the fix works
4. Commit: git commit -m "fix: ${vuln.title}"
5. Push and create PR with the generated title and description
    `.trim()
  });
}));

module.exports = router;
