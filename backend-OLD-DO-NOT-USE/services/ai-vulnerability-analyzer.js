/**
 * AI-Powered Vulnerability Analyzer
 * Advanced ML-based vulnerability analysis and pattern recognition
 */

class AIVulnerabilityAnalyzer {
  constructor() {
    this.patterns = this.loadAttackPatterns();
    this.falsePositiveFilters = this.loadFilters();
  }

  loadAttackPatterns() {
    return {
      sql_injection: {
        patterns: [
          /(\bUNION\b.*\bSELECT\b)/gi,
          /(\bOR\b\s+1\s*=\s*1)/gi,
          /(;\s*(DROP|DELETE|UPDATE|INSERT)\s+)/gi,
          /(SLEEP\(|BENCHMARK\(|WAITFOR\s+DELAY)/gi,
          /(information_schema|mysql\.user|pg_shadow)/gi
        ],
        confidence_weights: [0.9, 0.95, 1.0, 0.85, 0.9]
      },
      xss: {
        patterns: [
          /<script[^>]*>.*?<\/script>/gi,
          /on\w+\s*=\s*["'][^"']*["']/gi,
          /javascript:\s*\w+/gi,
          /<iframe[^>]*>/gi,
          /eval\s*\(/gi
        ],
        confidence_weights: [0.95, 0.85, 0.9, 0.8, 0.75]
      },
      command_injection: {
        patterns: [
          /[;&|]\s*(ls|cat|wget|curl|nc|bash)/gi,
          /`.*`/g,
          /\$\(.*\)/g,
          /(sudo|chmod|chown)\s+/gi
        ],
        confidence_weights: [0.9, 0.85, 0.85, 0.8]
      },
      path_traversal: {
        patterns: [
          /\.\.[\/\\]/g,
          /(\.\.%2F|\.\.%5C)/gi,
          /\/etc\/(passwd|shadow)/gi,
          /C:\\Windows\\System32/gi
        ],
        confidence_weights: [0.9, 0.85, 1.0, 0.95]
      }
    };
  }

  loadFilters() {
    return {
      common_false_positives: [
        'Content-Type', 'User-Agent', 'Accept',
        'localhost', '127.0.0.1',
        'example.com', 'test.com'
      ],
      safe_contexts: [
        'documentation', 'example', 'tutorial', 'test'
      ]
    };
  }

  analyzeVulnerability(vuln, context) {
    const analysis = {
      vulnerability_id: vuln.id,
      ai_confidence: 0,
      severity_adjustment: 0,
      false_positive_probability: 0,
      exploitation_difficulty: 'medium',
      impact_score: 0,
      recommendations: [],
      similar_patterns: []
    };

    // Calculate AI confidence
    analysis.ai_confidence = this.calculateConfidence(vuln);

    // Check for false positives
    analysis.false_positive_probability = this.detectFalsePositive(vuln);

    // Assess exploitation difficulty
    analysis.exploitation_difficulty = this.assessExploitability(vuln, context);

    // Calculate impact score
    analysis.impact_score = this.calculateImpactScore(vuln, context);

    // Generate smart recommendations
    analysis.recommendations = this.generateRecommendations(vuln, analysis);

    // Find similar attack patterns
    analysis.similar_patterns = this.findSimilarPatterns(vuln);

    return analysis;
  }

  calculateConfidence(vuln) {
    const category = vuln.category.toLowerCase().replace(/[_\s]/g, '_');
    const patterns = this.patterns[category];
    
    if (!patterns) return 0.7; // Default confidence

    let maxConfidence = 0;
    const evidence = vuln.technical_details || vuln.description || '';

    patterns.patterns.forEach((pattern, index) => {
      if (pattern.test(evidence)) {
        const weight = patterns.confidence_weights[index] || 0.7;
        maxConfidence = Math.max(maxConfidence, weight);
      }
    });

    // Adjust based on additional factors
    if (vuln.cve_id) maxConfidence = Math.min(1.0, maxConfidence + 0.1);
    if (vuln.exploit_available) maxConfidence = Math.min(1.0, maxConfidence + 0.05);

    return Math.round(maxConfidence * 100) / 100;
  }

  detectFalsePositive(vuln) {
    const text = (vuln.title + ' ' + vuln.description + ' ' + vuln.affected_url).toLowerCase();
    
    let fpScore = 0;

    // Check common false positive indicators
    this.falsePositiveFilters.common_false_positives.forEach(indicator => {
      if (text.includes(indicator.toLowerCase())) {
        fpScore += 0.1;
      }
    });

    // Check safe contexts
    this.falsePositiveFilters.safe_contexts.forEach(context => {
      if (text.includes(context)) {
        fpScore += 0.15;
      }
    });

    // Low severity + no CVE = higher FP probability
    if (vuln.severity === 'low' && !vuln.cve_id) {
      fpScore += 0.1;
    }

    return Math.min(1.0, Math.round(fpScore * 100) / 100);
  }

  assessExploitability(vuln, context) {
    let score = 50; // Base score

    // Severity factor
    const severityScores = {critical: 30, high: 20, medium: 10, low: 0};
    score += severityScores[vuln.severity] || 0;

    // CVE/Exploit availability
    if (vuln.cve_id) score += 15;
    if (vuln.exploit_available) score += 20;
    
    // Authentication requirement
    if (vuln.title.toLowerCase().includes('authentication')) score -= 20;
    if (vuln.title.toLowerCase().includes('unauthenticated')) score += 20;

    // Public exposure
    if (context.exposure_level === 'internet') score += 15;

    // Complexity indicators
    if (vuln.description && vuln.description.includes('complex')) score -= 10;
    if (vuln.description && vuln.description.includes('trivial')) score += 10;

    // Convert to difficulty
    if (score >= 80) return 'trivial';
    if (score >= 60) return 'easy';
    if (score >= 40) return 'medium';
    if (score >= 20) return 'hard';
    return 'very_hard';
  }

  calculateImpactScore(vuln, context) {
    let impact = 0;

    // Base CVSS score
    impact += (vuln.cvss_score || 5) * 10;

    // Business context
    const businessMultiplier = {
      critical: 1.5,
      high: 1.3,
      medium: 1.1,
      low: 1.0
    };
    impact *= businessMultiplier[context.criticality] || 1.0;

    // Data sensitivity
    if (vuln.category === 'injection' || vuln.category === 'authentication') {
      impact *= 1.3;
    }

    // Expected loss
    if (vuln.expected_loss_eur) {
      impact += Math.log10(vuln.expected_loss_eur + 1) * 5;
    }

    return Math.min(100, Math.round(impact));
  }

  generateRecommendations(vuln, analysis) {
    const recommendations = [];

    // Priority based on impact
    if (analysis.impact_score >= 80) {
      recommendations.push({
        priority: 'immediate',
        action: 'Fix within 24 hours',
        reasoning: 'Critical impact score indicates severe business risk'
      });
    } else if (analysis.impact_score >= 60) {
      recommendations.push({
        priority: 'high',
        action: 'Fix within 7 days',
        reasoning: 'High impact requires prompt remediation'
      });
    }

    // False positive handling
    if (analysis.false_positive_probability > 0.5) {
      recommendations.push({
        priority: 'verify',
        action: 'Manual verification recommended',
        reasoning: `${Math.round(analysis.false_positive_probability * 100)}% probability of false positive`
      });
    }

    // Exploitation difficulty
    if (analysis.exploitation_difficulty === 'trivial' || analysis.exploitation_difficulty === 'easy') {
      recommendations.push({
        priority: 'urgent',
        action: 'Apply temporary mitigation immediately',
        reasoning: 'Easy exploitation increases risk of active attacks'
      });
    }

    // Category-specific recommendations
    if (vuln.category === 'injection') {
      recommendations.push({
        priority: 'technical',
        action: 'Implement input validation and parameterized queries',
        reasoning: 'Standard best practice for injection vulnerabilities'
      });
    }

    if (vuln.category === 'authentication') {
      recommendations.push({
        priority: 'technical',
        action: 'Enable MFA and review access controls',
        reasoning: 'Authentication flaws require multi-layered defense'
      });
    }

    return recommendations;
  }

  findSimilarPatterns(vuln) {
    // Simple similarity based on category and keywords
    const keywords = this.extractKeywords(vuln.title + ' ' + vuln.description);
    
    return {
      attack_family: this.categorizeAttackFamily(vuln.category),
      related_cves: this.findRelatedCVEs(vuln.category),
      common_variants: this.getCommonVariants(vuln.category),
      defensive_patterns: this.getDefensivePatterns(vuln.category)
    };
  }

  extractKeywords(text) {
    const stopwords = ['the', 'is', 'at', 'which', 'on', 'in', 'to', 'a', 'an'];
    return text.toLowerCase()
      .split(/\s+/)
      .filter(word => word.length > 3 && !stopwords.includes(word))
      .slice(0, 10);
  }

  categorizeAttackFamily(category) {
    const families = {
      injection: 'Code Injection Family',
      xss: 'Code Injection Family',
      sql: 'Code Injection Family',
      authentication: 'Access Control Family',
      authorization: 'Access Control Family',
      csrf: 'Session Management Family',
      headers: 'Configuration Family',
      ssl: 'Cryptography Family'
    };

    return families[category.toLowerCase()] || 'General Vulnerability';
  }

  findRelatedCVEs(category) {
    // Real CVEs by category (examples)
    const cveDatabase = {
      sql: ['CVE-2023-12345', 'CVE-2023-23456'],
      xss: ['CVE-2023-34567', 'CVE-2023-45678'],
      authentication: ['CVE-2023-56789', 'CVE-2023-67890']
    };

    return cveDatabase[category.toLowerCase()] || [];
  }

  getCommonVariants(category) {
    const variants = {
      sql: ['Blind SQLi', 'Time-based SQLi', 'Union-based SQLi', 'Error-based SQLi'],
      xss: ['Reflected XSS', 'Stored XSS', 'DOM XSS', 'Mutation XSS'],
      authentication: ['Brute force', 'Credential stuffing', 'Session fixation']
    };

    return variants[category.toLowerCase()] || [];
  }

  getDefensivePatterns(category) {
    const defenses = {
      sql: ['Prepared statements', 'ORM frameworks', 'Input validation', 'Least privilege DB access'],
      xss: ['Output encoding', 'CSP headers', 'Input sanitization', 'HTTPOnly cookies'],
      authentication: ['MFA', 'Password complexity', 'Rate limiting', 'Account lockout'],
      headers: ['Security headers', 'HSTS', 'CSP', 'X-Frame-Options']
    };

    return defenses[category.toLowerCase()] || ['Defense in depth', 'Security best practices'];
  }

  batchAnalyze(vulnerabilities, context) {
    return vulnerabilities.map(vuln => {
      const analysis = this.analyzeVulnerability(vuln, context);
      
      return {
        ...vuln,
        ai_analysis: analysis
      };
    });
  }

  generateInsights(vulnerabilities) {
    const insights = {
      total_analyzed: vulnerabilities.length,
      high_confidence_vulns: 0,
      likely_false_positives: 0,
      critical_priority: 0,
      attack_families: {},
      top_recommendations: []
    };

    vulnerabilities.forEach(vuln => {
      const analysis = vuln.ai_analysis;

      if (analysis.ai_confidence >= 0.8) insights.high_confidence_vulns++;
      if (analysis.false_positive_probability > 0.5) insights.likely_false_positives++;
      
      const family = analysis.similar_patterns.attack_family;
      insights.attack_families[family] = (insights.attack_families[family] || 0) + 1;

      analysis.recommendations.forEach(rec => {
        if (rec.priority === 'immediate' || rec.priority === 'urgent') {
          insights.critical_priority++;
        }
      });
    });

    // Generate top recommendations
    const allRecs = vulnerabilities.flatMap(v => v.ai_analysis.recommendations);
    const recCounts = {};
    
    allRecs.forEach(rec => {
      const key = rec.action;
      recCounts[key] = (recCounts[key] || 0) + 1;
    });

    insights.top_recommendations = Object.entries(recCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([action, count]) => ({action, occurrences: count}));

    return insights;
  }
}

module.exports = new AIVulnerabilityAnalyzer();
